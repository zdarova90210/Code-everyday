# Использование `track` (ранее `trackBy`) в @for (*ngFor)

### Пример:

```angular181html

<div class="cards-grid">
    <!--либо, например, track value.id-->
    @for (value of values; track $index) {
        <app-card [value]="value"></app-card>
    }
</div>
```

### Зачем нужен `track`?

`track` используется для оптимизации работы Angular с HTML-элементами в сценах, где происходит рендеринг коллекций
данных с помощью директив вроде `@for` или `*ngFor`. Эта оптимизация помогает избежать лишнего перерасчёта и полной
переработки DOM-дерева при изменении данных.

---

### Проблема без `track`

Если не указывать `track` (или `trackBy` в более старых версиях для `*ngFor`), Angular использует **сравнение по ссылке
** для определения изменений. Это означает, что при любом обновлении массива Angular будет воспринимать все элементы как
новые, даже если изменился лишь один элемент.

**Пример без трекинга:**

```typescript
values = [{id: 1, name: 'Item 1'}, {id: 2, name: 'Item 2'}];
// Заменяем элемент:
values = [...values, {id: 3, name: 'Item 3'}];
// В итоге Angular пересоздаёт все DOM-узлы, даже если { id: 1 } и { id: 2 } остались без изменений.
```

При этом Angular удаляет существующие DOM-элементы для элементов коллекции и создаёт их заново, что может быть
ресурсоёмким, особенно в случае сложных компонентов.

---

### Как работает `track`?

`track` позволяет Angular сопоставлять старые и новые элементы массива **по уникальному идентификатору** либо ключу. Это
позволяет избежать перерасчёта для неизменённых элементов.

В выражении `track`, указывается, что Angular должен использовать для идентификации элементов. Например:

```angular181html

<div class="cards-grid">
    @for (value of values; track value.id) {
        <app-card [value]="value"></app-card>
    }
</div>
```

Теперь Angular будет использовать свойство `id` для сравнения старого и нового массива. Если у элемента с `id: 1` данные
остались неизменными, Angular оставит соответствующий DOM-узел без изменений.

---

### Механизм работы

1. При первом вызове Angular создаёт DOM-элементы для всех данных.
2. При изменении массива, Angular вычисляет **разницу** между элементами старого и нового массивов, используя указанное
   выражение (например, `value.id`).
3. Angular пересоздаёт DOM только для тех элементов, которые действительно изменились.
4. Старые DOM-элементы, которые соответствуют элементам нового массива, остаются без изменений.

---

### Пример с изменением массива

```typescript
values = [
    {id: 1, name: 'Item 1'},
    {id: 2, name: 'Item 2'}
];

// Меняем данные (добавили новый элемент):
values = [
    {id: 1, name: 'Item 1'}, // неизменённый элемент
    {id: 2, name: 'Item 2'}, // неизменённый элемент
    {id: 3, name: 'Item 3'}  // новый элемент
];
```

Для массива выше Angular:

- Перенесёт существующие элементы с `id: 1` и `id: 2` в новый список, без их пересоздания.
- Срендерит только новый элемент с `id: 3`.

---

### Пример с индексами `track $index`

Если данные массива не имеют уникального идентификатора, можно использовать индекс из массива (не всегда рекомендуется,
но в простых случаях подходит):

```angular181html

<div class="cards-grid">
    @for (value of values; track $index) {
        <app-card [value]="value"></app-card>
    }
</div>
```

Однако, если данные изменяются местами в массиве (например, сортировка), `track $index` может быть неэффективным, так
как Angular считает элементы перетасованными, и пересоздаёт DOM-ноды. Для таких случаев лучше использовать уникальные
ключи.

---

### Когда использовать `track`?

`track` следует использовать при работе с массивами, в которых:

1. Есть большие объёмы данных.
2. Элементы могут изменяться, добавляться, удаляться или перетасовываться.
3. Вы хотите повысить производительность обновления DOM.

---

### Упрощённо: Эффективность с `track`

- **Без `track`:** Angular уничтожает старые DOM-ноды и создаёт новые, даже если данные идентичны.
- **С `track`:** Angular обновляет только изменённые элементы, повторно используя неизменённые.